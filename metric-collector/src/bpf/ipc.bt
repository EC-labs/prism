#!/home/diogo/.local/bin/bpftrace

#include <linux/stat.h>
#include <linux/fs.h>
#include <linux/net.h>
#include <linux/socket.h>
#include <net/sock.h>

struct epoll_filefd {
	struct file *file;
	int fd;
};

struct epitem {
	union {
		struct rb_node rbn;
		struct rcu_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;

};


BEGIN 
/ str($2) == "debug" /
{
    @pids[$1] = 1;
}

/* This probe is used to register new pids. 
 * 
 * The first argument is the pid of the metric collector sending the event. The
 * new pid is extracted from the mode argument passed in via the mode system *
 * call parameter.
 */
tracepoint:syscalls:sys_enter_access
/ pid == $1 /
{
    $filename = str(args->filename);
    if ($filename != "metric-collector-new-pid") {
        return;
    }

    $new_pid = (uint32) args->mode;
    if (!@pids[$new_pid]) {
        @pids[$new_pid] = 1;
    }
}



/* 
 * STREAMS
 */
kfunc:vmlinux:vfs_read
{
    $inode = (struct inode *)args->file->f_inode;
    $mode = $inode->i_mode;

    if ((($mode & S_IFMT) == S_IFIFO) || (($mode & S_IFMT) == S_IFCHR)) {
        $i_id = $inode->i_ino;
        $s_dev = $inode->i_sb->s_dev;

        if (!@files[$s_dev, $i_id]) {
            if (@pids[pid]) {
                @files[$s_dev, $i_id] = 1;
            }
        } 

        if (!@files[$s_dev, $i_id]) {
            return;
        }

        if (!@pids[pid]) {
            printf("%s\t%s\t%lld\n", 
                   "NewProcess", comm, pid);
            @pids[pid] = 1
        }

        @start_file[tid, $s_dev, $i_id] = nsecs;
        printf("%s\t%lld\t%lld\t%lld\t%lld\n", 
               "ReadStart", tid, $s_dev, $i_id, @start_file[tid, $s_dev, $i_id]);
    } 
}

kretfunc:vmlinux:vfs_read 
{
    $inode = (struct inode *)args->file->f_inode;
    $mode = $inode->i_mode;

    if ((($mode & S_IFMT) == S_IFIFO) || (($mode & S_IFMT) == S_IFCHR)) {
        $i_id = $inode->i_ino;
        $s_dev = $inode->i_sb->s_dev;

        if (!@start_file[tid, $s_dev, $i_id]) {
            return;
        }

        printf("%s\t%lld\t%lld\t%lld\t%lld\n", 
               "ReadEnded", tid, $s_dev, $i_id, nsecs - @start_file[tid, $s_dev, $i_id]);
        delete(@start_file[tid, $s_dev, $i_id]);
    }    
}

kfunc:vmlinux:vfs_write
{
    $inode = (struct inode *)args->file->f_inode;
    $mode = $inode->i_mode;

    if ((($mode & S_IFMT) == S_IFIFO) || (($mode & S_IFMT) == S_IFCHR)) {
        $i_id = $inode->i_ino;
        $s_dev = $inode->i_sb->s_dev;

        if (!@files[$s_dev, $i_id]) {
            if (@pids[pid]) {
                @files[$s_dev, $i_id] = 1;
            }
        } 

        if (!@files[$s_dev, $i_id]) {
            return;
        }

        if (!@pids[pid]) {
            printf("%s\t%s\t%lld\n", 
                   "NewProcess", comm, pid);
            @pids[pid] = 1
        }

        @start_file[tid, $s_dev, $i_id] = nsecs;
        printf("%s\t%lld\t%lld\t%lld\t%lld\n", 
               "WriteStart", tid, $s_dev, $i_id, @start_file[tid, $s_dev, $i_id]);
    }
}

kretfunc:vmlinux:vfs_write 
{
    $inode = (struct inode *)args->file->f_inode;
    $mode = $inode->i_mode;

    if ((($mode & S_IFMT) == S_IFIFO) || (($mode & S_IFMT) == S_IFCHR)) {
        $i_id = $inode->i_ino;
        $s_dev = $inode->i_sb->s_dev;

        if (!@start_file[tid, $s_dev, $i_id]) {
            return;
        }

        printf("%s\t%lld\t%lld\t%lld\t%lld\n", 
               "WriteEnd", tid, $s_dev, $i_id, nsecs - @start_file[tid, $s_dev, $i_id]);
        delete(@start_file[tid, $s_dev, $i_id]);
    }
}



/*
 * SOCKETS
 */
kfunc:vmlinux:tcp_connect
{
    if (!@pids[pid]) {
        return;
    }

    $sk = args->sk;
    $inet_family = $sk->__sk_common.skc_family;

    if ($inet_family != AF_INET) {
        return;
    }

    $daddr = ntop($sk->__sk_common.skc_daddr);
    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);
    $lport = $sk->__sk_common.skc_num;
    $dport = $sk->__sk_common.skc_dport;
    $dport = bswap($dport);

    if (!@socks[$saddr, $lport, $daddr, $dport]) {
        @socks[$saddr, $lport, $daddr, $dport] = 1;
    }
    @start_sock[tid] = nsecs;
    printf("ConnectStart\t%lld\t%s\t%s\t%d\t%s\t%d\n", tid, comm, $saddr, $lport, $daddr, $dport);
}


kretfunc:vmlinux:tcp_connect
/ @start_sock[tid] /
{
    printf("%s\t%lld\t%s\t%lld\n",
           "ConnectEnded", tid, comm, nsecs - @start_sock[tid]);
    delete(@start_sock[tid]);
}

kfunc:vmlinux:do_accept 
{
    if (!@pids[pid]) {
        return;
    }

    $socket = (struct socket *)args->file->private_data;
    $sk = $socket->sk;
	$inet_family = $sk->__sk_common.skc_family;
    
    if ($inet_family != AF_INET) {
        return;
    }

    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);
    $lport = $sk->__sk_common.skc_num;

    @start_sock[tid] = nsecs;
    printf("AcceptStart\t%lld\t%s\t%s\t%d\n", tid, comm, $saddr, $lport);
}

kretprobe:inet_csk_accept
{
	$sk = (struct sock *)retval;
	$inet_family = $sk->__sk_common.skc_family;

	if ($inet_family != AF_INET) {
        return;
	}

    $daddr = ntop($sk->__sk_common.skc_daddr);
    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);

    $lport = $sk->__sk_common.skc_num;
    $dport = $sk->__sk_common.skc_dport;
    $dport = bswap($dport);

    $qlen  = $sk->sk_ack_backlog;
    $qmax  = $sk->sk_max_ack_backlog;

    if (@socks[$daddr, $dport, $saddr, $lport] && !@pids[pid]) {
        printf("%s\t%s\t%lld\n", 
               "NewProcess", comm, pid);
        @pids[pid] = 1;
    }
    printf("AcceptEnded\t%lld\t%s\t%s\t%d\t%s\t%d\t%lld\n", 
           tid, comm, $saddr, $lport, $daddr, $dport, nsecs - @start_sock[tid]);
    delete(@start_sock[tid]);
}

kfunc:vmlinux:sock_recvmsg
{
    if (!@pids[pid]) {
        return;
    }
    
    $inode = (struct inode *)args->sock->file->f_inode;
	$sk = args->sock->sk;
	$inet_family = $sk->__sk_common.skc_family;

    if ($inet_family != AF_INET) {
        return;
    }

    $daddr = ntop($sk->__sk_common.skc_daddr);
    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);

    $lport = $sk->__sk_common.skc_num;
    $dport = $sk->__sk_common.skc_dport;
    $dport = bswap($dport);

    @start_sock[tid] = nsecs;
    printf("%s\t%lld\t%s\t%s\t%d\t%s\t%d\n", 
           "RecvStart", tid, comm, $saddr, $lport, $daddr, $dport);
}

kretfunc:vmlinux:sock_recvmsg
/ @start_sock[tid] /
{
    printf("%s\t%lld\t%s\t%lld\n",
           "RecvEnded", tid, comm, nsecs - @start_sock[tid]);
    delete(@start_sock[tid]);
}

kfunc:vmlinux:inet_sendmsg
{
    if (!@pids[pid]) {
        return;
    }

    $inode = (struct inode *)args->sock->file->f_inode;
	$sk = args->sock->sk;
	$inet_family = $sk->__sk_common.skc_family;

    if ($inet_family != AF_INET) {
        return;
    }

    $daddr = ntop($sk->__sk_common.skc_daddr);
    $saddr = ntop($sk->__sk_common.skc_rcv_saddr);

    $lport = $sk->__sk_common.skc_num;
    $dport = $sk->__sk_common.skc_dport;
    $dport = bswap($dport);

    @start_sock[tid] = nsecs;
    printf("%s\t%lld\t%s\t%s\t%d\t%s\t%d\n", 
           "SendStart", tid, comm, $saddr, $lport, $daddr, $dport);
}

kretfunc:vmlinux:inet_sendmsg
/ @start_sock[tid] /
{
    printf("%s\t%lld\t%s\t%lld\n", 
           "SendEnded", tid, comm, nsecs - @start_sock[tid]);
    delete(@start_sock[tid]);
}



/*
 * EPOLL
 */
kfunc:vmlinux:do_epoll_wait
{
    if (!@pids[pid]) {
        return;
    }

    printf("EpollWaiting\t%lld\t%s\n", tid, comm);
}

kretfunc:vmlinux:do_epoll_wait
{
    if (!@pids[pid]) {
        return;
    }

    printf("RetEpollWait\t%lld\t%s\n", tid, comm);
}

kprobe:ep_send_events
{
    if (!@pids[pid]) {
        return;
    }

    @epoll_send[tid] = 1;
}

kretprobe:ep_send_events
/ @epoll_send[tid] /
{
    delete(@epoll_send[tid]);
}

kprobe:ep_item_poll*
/ @epoll_send[tid] /
{
    $epi = (struct epitem *) arg0;
    $ffd = $epi->ffd;
    $inode = $ffd.file->f_inode;
    printf("EpiPolled\t%lld\t%s\t%d\t%lld\t%lld\n", tid, comm, $ffd.fd, $inode->i_sb->s_dev, $inode->i_ino);
}

END 
{
    clear(@start_file);
    clear(@start_sock);
    clear(@files);
    clear(@pids);
    clear(@socks);
}
